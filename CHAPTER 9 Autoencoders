#Import the needed libraries
import numpy as np
import matplotlib.pyplot as plt

from tensorflow.keras import layers, models  
import tensorflow.keras.backend as K

#Import the Model class
from keras.models import Model
#IMPORT THE DATA INTO TRAIN AND TEST SETS 
from tensorflow.keras import datasets
(x_train,y_train), (x_test,y_test) = datasets.fashion_mnist.load_data()

#Scale the images using a preprocess function
def preprocess(imgs):
   imgs = imgs.astype("float32") / 255.0
   imgs = np.pad(imgs, ((0, 0), (2, 2), (2, 2)), constant_values=0.0)
   imgs = np.expand_dims(imgs, -1)
   return imgs
x_train = preprocess(x_train)
x_test = preprocess(x_test)

#THE ENCODER CODE
encoder_input = layers.Input(shape=(32, 32, 1), name = "encoder_input")
x = layers.Conv2D(10, (4, 4), strides = 1, activation = 'relu', padding="same")(encoder_input)
x = layers.Conv2D(50, (4, 4), strides = 1, activation = 'relu', padding="valid")(x)
x = layers.Conv2D(150, (4, 4), strides = 1, activation = 'relu', padding="valid")(x)
pre_flattened_shape = K.int_shape(x)[1:]
x = layers.Flatten()(x)
encoder_output = layers.Dense(4, name="encoder_output")(x)
encoder = models.Model(encoder_input, encoder_output)


#THE DECODER CODE
decoder_input = layers.Input(shape=(4,), name="decoder_input")
x = layers.Dense(np.prod(pre_flattened_shape))(decoder_input)
x = layers.Reshape(pre_flattened_shape)(x)
x = layers.Conv2DTranspose(
150, (4,4), strides=1, activation = 'relu', padding="valid"
)(x)
x = layers.Conv2DTranspose(
50, (4,4), strides=1, activation = 'relu', padding="valid"
)(x)
x = layers.Conv2DTranspose(
10, (4,4), strides=1, activation = 'relu', padding="same"
)(x)
decoder_output = layers.Conv2D(
1,
(4,4),
strides = 1,
activation="sigmoid",
padding="same",
name="decoder_output"
)(x)
decoder = models.Model(decoder_input, decoder_output)
#Show the encoder’s output layers’ shapes and number of parameters
print("ENCODER'S MODEL SUMMARY")
encoder.summary()
print()
print()

#Show the decoder’s output layers’ shapes and number of parameters
print("DECODER'S MODEL SUMMARY")
decoder.summary()

# COMBINE THE ENCODER WITH THE DECODER
autoencoder = Model(encoder_input, decoder(encoder_output))

# Compile the autoencoder
autoencoder.compile(optimizer="adam", loss="binary_crossentropy")

# Train the autoencoder by passing in the input images as both the input and #output with one epoch

autoencoder.fit(
   x_train,
   x_train,
   epochs=1,
   batch_size=200,
   shuffle=True,
   validation_data=(x_test, x_test),
)
#Reconstruct ten images from the test set
example_images = x_test[:10]
predictions = autoencoder.predict(example_images)

#Display the ten images
# figsize is width and height in inches
for i in range(10):
   
    plt.figure(figsize=(2,2))
    
    plt.imshow(predictions[i], cmap="gray_r") 
    plt.show()


# Show the numerica1 representation of the first ten images
representations = encoder.predict(example_images)
print(representations)

#Generate a totally new image from 4 numbers  
print()
print()
print("New Image Generated by AI:")
arr = np.array([[-25,8,4,12]])
con = decoder.predict(arr)
 #Display the generated image
plt.figure(figsize=(2,2))    
plt.imshow(con[0], cmap="gray_r") 
plt.show()

 
